//////////////////////////
// 2022.10.19 / kkarung //
//          DP          //
//       Bottom-up      //
//////////////////////////
////////////////////////// report ////////////////////////////////
// 이전 10844.cpp 에서 발견했던 풀이를 참고하여 메모리를 덜 쓰는 방향으로 풀어보았다
// 한 번 n자릿수 이친수를 구하면, 다음 n+1자릿수의 이친수를 계산할 때를 제외하고는 안 쓰인다는 특징을 이용하여 가장 최신 자릿수만 가지도록 하였다
// T는 임시 보관 용도의 배열, DP[0]은 0으로 끝났을 때의 이친수 개수, DP[1]은 1로 (이하생략)
// 0으로 끝나면 이전 자릿수가 1로 끝나든, 0으로 끝나던 둘 다 쓸 수 있다
// 1으로 끝나면 이전 자릿수가 1로 끝나야 한다

#include <iostream>
using namespace std;

int main() {
	ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);

	int N;
	long long int DP[2] = {0}, T[2] = {0};
	cin >> N;

	DP[0] = DP[1] = 1; // 3자릿수 이친수는 100, 101 뿐 => DP[0]=1; DP[1]=1;
	// 4자릿수부터 계산 시작
	for (int i=4; i<=N; i++) {
		T[0] = DP[1]+DP[0];
		T[1] = DP[0];
		DP[0] = T[0];
		DP[1] = T[1];
	}
  
	if (N<3) cout << 1; // 1자리, 2자리 이친수는 전부 1이 답
	else cout << DP[0]+DP[1];
}
